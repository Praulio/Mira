# Discoveries - Project Mira

> Memoria dinámica entre iteraciones del Ralph Loop.

## Patrones Descubiertos
- **Ralph Loop en Factory:** Migrado de Claude Code a Droid Exec.
- **Clerk Auth Condicional:** Implementado patrón de inicialización condicional de Clerk basado en validez de API keys, permitiendo builds exitosos en desarrollo sin claves reales.

## Notas de Sesión
- **2026-01-14:** Configuración inicial del sistema Ralph con integración de skills de React.
- **2026-01-15:** Sesión 1.1: Setup del Proyecto.
  - **Next.js 16.1.2:** Instalado mediante `create-next-app@latest`. Usa Turbopack por defecto.
  - **Tailwind 4:** Configuración minimalista basada en `@tailwindcss/postcss`. No requiere `tailwind.config.ts`.
  - **ESLint Flat Config:** Implementado en `eslint.config.mjs`. Se añadieron ignores para `.factory`, `docs` y `specs`.
  - **React 19:** Incluido como dependencia base.
  - **Librerías Base:** Instaladas `lucide-react`, `clsx`, `tailwind-merge`.
  - **Bug Resuelto:** El instalador fallaba por nombre de proyecto con mayúsculas ("Mira"). Se usó un subdirectorio temporal para la creación y movimiento de archivos.
- **2026-01-15:** Sesión 1.2: Configuración de Clerk Auth.
  - **@clerk/nextjs 6.x:** Instalado y configurado con middleware de protección de rutas.
  - **Archivos creados:**
    - `middleware.ts`: Protección de rutas con bypass condicional si no hay keys válidas.
    - `.env.local` y `.env.example`: Variables de entorno para Clerk.
    - `app/sign-in/[[...sign-in]]/page.tsx`: Página de login con componente Clerk.
    - `app/sign-up/[[...sign-up]]/page.tsx`: Página de registro con componente Clerk.
  - **Patrón de Build Robusto:** Implementada verificación de validez de keys de Clerk (`pk_test_placeholder` vs keys reales) en `layout.tsx` y `middleware.ts`, permitiendo que el proyecto compile exitosamente en desarrollo local sin necesidad de obtener keys reales de Clerk dashboard.
  - **Layout actualizado:** `ClerkProvider` envuelve la app condicionalmente solo cuando hay keys válidas.
  - **Metadata actualizada:** Título y descripción reflejan "Mira Tasker".
- **2026-01-15:** Sesión 1.3: Setup de Base de Datos (Neon + Drizzle).
  - **Dependencias instaladas:**
    - `drizzle-orm`: ORM TypeScript-first para PostgreSQL.
    - `@neondatabase/serverless`: Driver serverless de Neon compatible con edge runtime.
    - `drizzle-kit` (dev): Herramientas CLI para migraciones y generación de schemas.
  - **Archivos creados:**
    - `drizzle.config.ts`: Configuración de Drizzle Kit para migraciones con dialect `postgresql`.
    - `db/index.ts`: Conexión serverless con Neon usando Pool. Incluye validación de `DATABASE_URL`.
  - **Variables de entorno:** Añadida `DATABASE_URL` a `.env.example` y `.env.local` (con placeholders).
  - **Patrón de Conexión:** Se usa `Pool` de `@neondatabase/serverless` para compatibilidad con edge runtime y serverless functions.
  - **Build Status:** ✅ Lint y build pasaron exitosamente sin errores.
- **2026-01-15:** Sesión 1.4: Implementación de Webhook de Clerk para User Sync.
  - **Dependencia instalada:**
    - `svix`: Librería oficial para validación de signatures de webhooks de Clerk.
  - **Archivos creados:**
    - `db/schema.ts`: Schema inicial con tabla `users` (id, email, name, imageUrl, slotIndex, timestamps).
    - `db/migrations/0000_classy_saracen.sql`: Primera migración SQL para crear tabla users.
    - `app/api/webhooks/clerk/route.ts`: Endpoint POST que maneja eventos `user.created` y `user.updated`.
    - `db/README.md`: Guía para ejecutar migraciones con Drizzle Kit.
  - **Archivos actualizados:**
    - `db/index.ts`: Importado schema para habilitar queries tipadas con Drizzle.
    - `.env.example`: Añadida variable `CLERK_WEBHOOK_SECRET` con instrucciones.
  - **Patrón de Webhook:** Validación de firma Svix en headers (`svix-id`, `svix-timestamp`, `svix-signature`), manejo de eventos con insert/update en DB, logs de errores en consola.
  - **Seguridad:** El webhook verifica la firma antes de procesar cualquier payload, previniendo requests no autorizados.
  - **Build Status:** ✅ Lint y build pasaron exitosamente. Ruta `/api/webhooks/clerk` visible en manifest de Next.js.
- **2026-01-15:** Sesión 2.1: Definición completa del Schema de Base de Datos.
  - **Schema actualizado:** Se añadieron tablas `tasks` y `activity` a `db/schema.ts`.
  - **Enums creados:**
    - `taskStatusEnum`: Define los 4 estados posibles de una tarea (backlog, todo, in_progress, done).
    - `activityActionEnum`: Define los tipos de eventos a registrar (created, status_changed, assigned, updated, deleted).
  - **Tabla tasks:** 
    - Campos: id (UUID), title, description, status (enum), assigneeId (FK nullable), creatorId (FK required), timestamps.
    - Foreign Keys: assigneeId y creatorId referencian a `users.id` con `onDelete: set null` y `cascade` respectivamente.
    - Índices: `tasks_assignee_idx`, `tasks_status_idx`, `tasks_creator_idx` para optimizar queries frecuentes.
  - **Tabla activity:**
    - Campos: id (UUID), taskId (FK nullable), userId (FK required), action (enum), metadata (JSONB), createdAt.
    - Foreign Keys: taskId referencia `tasks.id` y userId referencia `users.id`, ambos con `cascade`.
    - Índices: `activity_task_idx`, `activity_created_at_idx`, `activity_user_idx` para queries de histórico.
    - Metadata JSONB permite almacenar información adicional como old/new status en transiciones.
  - **Scripts de DB añadidos:** 
    - Instalado `dotenv-cli` para cargar variables de entorno en comandos de Drizzle Kit.
    - Scripts en `package.json`: `db:generate`, `db:push`, `db:studio`.
  - **Migración generada:** `db/migrations/0001_brave_moonstone.sql` contiene la creación de enums, tablas, foreign keys e índices.
  - **Patrón de Índices:** Se priorizan índices en columnas usadas frecuentemente en WHERE y JOIN clauses (assignee, status, created_at).
  - **Build Status:** ✅ Lint pasó con 1 warning no relacionado (middleware.ts), build completado exitosamente en 919ms. Schema compila sin errores TypeScript.
- **2026-01-15:** Sesión 2.2: Server Action - createTask.
  - **Zod 4.3.5:** Ya instalado como dependencia transitiva de `eslint-plugin-react-hooks`. No requirió instalación adicional.
  - **Archivo creado:**
    - `app/actions/tasks.ts`: Server Action para crear tareas con validación Zod, logging de actividad y revalidación de rutas.
  - **Patrón de Server Actions:**
    - Directiva `'use server'` al inicio del archivo.
    - Tipo estandarizado `ActionResponse<T>` con campos `success`, `data?`, `error?`.
    - Autenticación con `auth()` de Clerk antes de cualquier operación.
    - Validación de input con `safeParse()` de Zod, retornando el primer error de validación.
    - Manejo de errores con try-catch y logs en consola.
    - Uso de `revalidatePath()` para invalidar cache de rutas relevantes (/, /kanban, /backlog).
  - **Schema de Validación:**
    - `title`: String requerido, máximo 200 caracteres.
    - `description`: String opcional, máximo 2000 caracteres.
    - `assigneeId`: String opcional para asignar la tarea a un usuario.
  - **Lógica de Creación:**
    - Status por defecto: `'backlog'` (definido en schema de DB).
    - Inserción en tabla `tasks` con `.returning()` para obtener el registro creado.
    - Inserción en tabla `activity` con action `'created'` y metadata con título y assigneeId.
  - **Bug Resuelto:** Error TypeScript inicial al usar `validationResult.error.errors[0]` en Zod 4.x. La propiedad correcta es `validationResult.error.issues[0]` en versiones modernas de Zod.
  - **Build Status:** ✅ Lint pasó con 1 warning no relacionado (middleware.ts). Build completado exitosamente en 829ms. TypeScript compila sin errores.
- **2026-01-15:** Sesión 2.3: Server Action - updateTaskStatus (Lógica Crítica).
  - **Archivo actualizado:**
    - `app/actions/tasks.ts`: Añadida función `updateTaskStatus` con transacción atómica para implementar la regla de "Single In-Progress Task".
  - **Imports adicionales:** `eq` y `and` de `drizzle-orm` para queries condicionales.
  - **Schema de Validación:**
    - `taskId`: String UUID requerido.
    - `newStatus`: Enum con valores válidos ('backlog', 'todo', 'in_progress', 'done').
  - **Lógica de Single In-Progress Task:**
    1. Fetch de la tarea actual para obtener su assigneeId y status previo.
    2. Transacción atómica con `db.transaction()`:
       - Si `newStatus === 'in_progress'` y la tarea tiene assigneeId, ejecuta un UPDATE masivo moviendo TODAS las tareas `in_progress` del mismo assignee a `todo`.
       - Actualiza la tarea target con el nuevo status.
       - Inserta registro en tabla `activity` con action `'status_changed'` y metadata conteniendo oldStatus, newStatus y taskTitle.
    3. Revalidación de rutas (/, /kanban, /backlog).
  - **Patrón de Transacción:** Uso de `db.transaction(async (tx) => {})` de Drizzle para garantizar atomicidad. Si cualquier operación falla, todas se revierten automáticamente.
  - **Manejo de Edge Cases:**
    - Si la tarea no existe, retorna error `'Task not found'` antes de ejecutar la transacción.
    - Si la tarea no tiene assigneeId, no ejecuta la lógica de single-in-progress (permite múltiples tareas in_progress no asignadas).
  - **Activity Logging:** Metadata incluye `oldStatus`, `newStatus` y `taskTitle` para trazabilidad completa de cambios de estado.
  - **Build Status:** ✅ Lint pasó con 1 warning no relacionado (middleware.ts). Build completado exitosamente en 981ms con Turbopack. TypeScript compila sin errores. Función exportada correctamente como Server Action.
- **2026-01-15:** Sesión 2.4: Unit Tests para Lógica de Estados.
  - **Dependencias instaladas:**
    - `vitest@4.0.17`: Framework de testing rápido compatible con Vite/Next.js.
    - `@vitest/ui@4.0.17`: Interfaz web para visualización de tests.
    - `happy-dom@20.3.0`: Environment DOM ligero para tests (más rápido que jsdom).
  - **Archivos creados:**
    - `vitest.config.ts`: Configuración de Vitest con environment `happy-dom` y alias `@/` para imports absolutos.
    - `app/actions/__tests__/tasks.test.ts`: Suite de 9 tests unitarios para `updateTaskStatus`.
  - **Scripts añadidos:**
    - `test`: Ejecuta tests en modo CI (single run).
    - `test:watch`: Ejecuta tests en modo watch.
    - `test:ui`: Abre interfaz web de Vitest.
  - **Cobertura de Tests (9 tests, 100% passed):**
    1. **Authentication:** Rechaza requests sin autenticación.
    2. **Input Validation:** Rechaza UUIDs inválidos y status no permitidos.
    3. **Single In-Progress Logic (CRITICAL):**
       - Mueve otras tareas `in_progress` a `todo` cuando se activa una nueva.
       - NO mueve tareas si el nuevo status no es `in_progress` (ej: moving to `done`).
       - Maneja tareas sin assigneeId gracefully (skip lógica single-in-progress).
    4. **Error Handling:** Retorna error cuando la tarea no existe.
    5. **Transaction Errors:** Maneja fallos de DB con error message amigable.
    6. **Activity Logging:** Verifica que se inserte registro en tabla `activity`.
  - **Patrón de Testing:**
    - Mocking de módulos externos: `@clerk/nextjs/server`, `next/cache`, `@/db`.
    - Uso de tipos explícitos para mocks (`type MockTx`) en vez de `any` para cumplir con linting.
    - `beforeEach` para resetear mocks y configurar estado default (usuario autenticado).
    - `afterEach` para limpiar mocks.
  - **Bug Resuelto durante Lint:**
    - Variables no utilizadas `otherTaskId1` y `otherTaskId2` removidas.
    - Tipos `any` reemplazados por tipo explícito `MockTx` con definición de propiedades.
    - Parámetro `table` no utilizado removido de mock de `insert()`.
  - **Build Status:** ✅ 9/9 tests passed. Lint pasó (solo 1 warning pre-existente en middleware.ts). Build completado exitosamente en 1049ms. TypeScript compila sin errores.
- **2026-01-15:** Sesión 2.5: Server Actions - deleteTask y updateTaskMetadata.
  - **Archivo actualizado:**
    - `app/actions/tasks.ts`: Añadidas dos nuevas Server Actions con validación Zod, transacciones atómicas y activity logging.
  - **Schemas de Validación:**
    - `deleteTaskSchema`: Valida UUID del taskId.
    - `updateTaskMetadataSchema`: Valida taskId (UUID), title opcional (1-200 chars), description opcional (0-2000 chars). Incluye refinamiento Zod para garantizar que al menos un campo sea provisto.
  - **deleteTask:**
    - Verifica autenticación con Clerk.
    - Fetch de la tarea para verificar existencia y capturar metadata antes de borrado.
    - Transacción atómica: Inserta registro en `activity` con action `'deleted'` y metadata (title, status, assigneeId) ANTES de ejecutar el DELETE.
    - El DELETE en DB usa CASCADE (definido en schema) para eliminar automáticamente registros relacionados en `activity`.
    - Revalidación de rutas (/, /kanban, /backlog).
  - **updateTaskMetadata:**
    - Permite actualización parcial de title y/o description.
    - Fetch de la tarea para obtener valores previos (oldTitle, oldDescription).
    - Construye objeto `updateData` dinámicamente incluyendo solo campos provistos.
    - Transacción atómica: UPDATE de la tarea + INSERT en activity con metadata completa (old/new values, fieldsUpdated flags).
    - Revalidación de rutas (/, /kanban, /backlog).
  - **Patrón de Activity Logging:**
    - `deleteTask`: Logs ANTES del DELETE para preservar referencia al taskId antes de CASCADE.
    - `updateTaskMetadata`: Logs metadata con comparación old vs new para trazabilidad completa de cambios.
  - **Build Status:** ✅ Lint pasó (1 warning pre-existente). Build completado exitosamente en 1043ms con Turbopack. Tests existentes (9/9) siguen pasando. TypeScript compila sin errores.
- **2026-01-15:** Sesión 3.1: Layout Principal y Navigation.
  - **Shadcn/ui Instalado:**
    - Ejecutado `npx shadcn@latest init` con estilo "new-york", baseColor "neutral", y modo RSC habilitado.
    - Configuración generada en `components.json` con aliases para `@/components`, `@/lib`, `@/hooks`.
    - Instalado componente `button` de shadcn.
    - Archivo creado: `lib/utils.ts` con función helper `cn()` (classNames merge con tailwind-merge).
  - **Estructura de Rutas:**
    - Creado route group `app/(dashboard)` para páginas autenticadas.
    - Directorio `app/(dashboard)/dashboard` para rutas principales.
  - **Componentes creados:**
    - `components/sidebar.tsx`: Sidebar fijo de 64px con navegación hacia 4 vistas (Team View, Kanban, Backlog, Activity). Incluye highlighting del item activo basado en `usePathname()`.
    - `components/user-nav.tsx`: Wrapper client component para `UserButton` de Clerk con configuración de avatarBox.
    - `app/(dashboard)/layout.tsx`: Layout con sidebar fijo y área de contenido con top bar (título + UserButton). Usa `pl-64` para compensar sidebar fijo.
  - **Páginas placeholder creadas:**
    - `app/(dashboard)/dashboard/page.tsx`: Team View con grid de 8 slots vacíos (preparado para Task 3.2).
    - `app/(dashboard)/dashboard/kanban/page.tsx`: Kanban con 4 columnas placeholder (preparado para Task 4.1).
    - `app/(dashboard)/dashboard/backlog/page.tsx`: Backlog con lista vertical placeholder.
    - `app/(dashboard)/dashboard/activity/page.tsx`: Activity feed con 10 items placeholder (preparado para Task 5.1).
  - **Rutas configuradas:**
    - `/dashboard` → Team View (8-slot grid).
    - `/dashboard/kanban` → Kanban Board.
    - `/dashboard/backlog` → Backlog List.
    - `/dashboard/activity` → Activity Feed.
    - `/` → Redirige a `/dashboard` si autenticado, o `/sign-in` si no.
  - **Patrón de Dynamic Rendering:**
    - Todas las páginas del dashboard incluyen `export const dynamic = 'force-dynamic'` para evitar pre-rendering durante build, ya que requieren autenticación y datos de usuario.
    - Esto permite que el build pase exitosamente incluso sin Clerk keys válidas (usando el patrón condicional de ClerkProvider del layout raíz).
  - **Diseño implementado:**
    - Dark mode por defecto con colores neutral.
    - Sidebar con logo "M", navegación con iconos Lucide y descripciones de cada vista.
    - Footer en sidebar con versión "Mira Tasker v1.0.0".
    - Top bar sticky con título y UserButton.
  - **Bug Resuelto:**
    - Error de build: `UserButton can only be used within <ClerkProvider />`. Solución: Extraer UserButton a componente client separado (`user-nav.tsx`) e importarlo en el layout server component.
    - Warning de eslint: Variable `request` no utilizada en middleware.ts. Solución: Removido import `NextRequest` y parámetro del fallback middleware.
    - Agregado `/` a rutas públicas en middleware para permitir acceso durante build.
  - **Build Status:** ✅ Lint pasó sin warnings. Build completado exitosamente en 932ms con Turbopack. 9 rutas generadas correctamente (/, sign-in, sign-up, dashboard, kanban, backlog, activity, api/webhooks, 404). TypeScript compila sin errores.
- **2026-01-15:** Sesión 3.2: Grilla de Team View (The 8 Slots).
  - **Archivos creados:**
    - `app/actions/team.ts`: Server action `getTeamViewData()` que retorna array de TeamSlotData (usuarios + sus tareas in_progress).
    - `components/team-slot.tsx`: Componente presentacional para renderizar un slot individual con user info y task activa.
  - **Archivos actualizados:**
    - `app/(dashboard)/dashboard/page.tsx`: Reemplazado placeholder grid con integración de datos reales desde `getTeamViewData()`.
    - `next.config.ts`: Añadida configuración de `images.remotePatterns` para permitir avatares de Clerk desde `img.clerk.com`.
  - **Patrón de Data Fetching:**
    - Server Component en `page.tsx` ejecuta `await getTeamViewData()` para fetch de datos server-side (sin waterfalls cliente).
    - `getTeamViewData()` usa Promise.all para paralelizar queries de tareas in_progress de cada usuario (Best Practice: 1.4).
    - Query optimizada: Fetch de 8 usuarios ordenados por `slotIndex` (nulls primero), luego por `updatedAt` descendente.
    - Para cada usuario, fetch de su única tarea `in_progress` usando `and()` con dos condiciones: `assigneeId === userId` y `status === 'in_progress'`.
  - **TeamSlot Component:**
    - Props: `data: TeamSlotData | null`, `slotNumber: number`.
    - Renderiza estado vacío si no hay usuario asignado (icono User + "Empty").
    - Si hay usuario, muestra avatar (Next.js Image component), nombre, email.
    - Si tiene tarea in_progress, muestra badge "In Progress", título de tarea y tiempo transcurrido (helper `getTimeElapsed()`).
    - Si no tiene tarea activa, muestra "No active task".
  - **Optimizaciones de Performance:**
    - Uso de Next.js `<Image />` en vez de `<img>` para optimización automática de imágenes (Best Practice: 2.1).
    - Componente puro presentacional sin data fetching (minimiza serialización en RSC boundary - Best Practice: 3.2).
    - Time elapsed calculado con early returns (Best Practice: 7.8).
  - **Responsive Grid:**
    - CSS classes: `grid-cols-1 md:grid-cols-2 lg:grid-cols-4` para layout 1xN (mobile), 2xN (tablet), 2x4 (desktop).
    - Altura fija de slot: `h-48` (192px) para consistencia visual.
  - **Tipo Exportado:**
    - `TeamSlotData` definido y exportado desde `app/actions/team.ts` para reutilización en tipos de componentes.
  - **Bug Resuelto:**
    - Warning de lint inicial: Uso de `<img>` sin Next.js Image. Solución: Reemplazado por `<Image />` con `width={40}` y `height={40}`.
    - Error de build potencial: Imágenes externas bloqueadas. Solución: Configurado `remotePatterns` en `next.config.ts` con hostname `img.clerk.com`.
  - **Build Status:** ✅ Lint pasó sin warnings. Build completado exitosamente en 1184ms con Turbopack. TypeScript compila sin errores. Ruta `/dashboard` renderiza correctamente con 8 slots.
- **2026-01-15:** Sesión 3.3: Lógica de Datos para Team View (Loading States).
  - **Archivo creado:**
    - `app/(dashboard)/dashboard/loading.tsx`: Componente de loading UI con skeletons para el grid de 8 slots.
  - **Patrón de Loading UI:**
    - Archivo especial `loading.tsx` de Next.js 15 que se muestra automáticamente mientras se realiza el fetch server-side de `page.tsx`.
    - Componente `DashboardLoading` con header skeleton (título + descripción).
    - Componente helper `TeamSlotSkeleton` que replica la estructura visual de `TeamSlot` (avatar, nombre, badge, task title, time elapsed).
    - Uso de `animate-pulse` de Tailwind para efecto de shimmer en los placeholders.
    - Grid con mismo layout responsive que la página principal: `grid-cols-1 md:grid-cols-2 lg:grid-cols-4`.
  - **Optimizaciones de Performance:**
    - JSX estático hoistado (Best Practice: 6.3).
    - Dimensiones de skeleton coinciden con componentes reales para evitar layout shift al cargar datos.
    - Array.from({ length: 8 }) para renderizar 8 skeletons de manera determinística.
  - **Manejo de Estados Vacíos:**
    - Verificado que `getTeamViewData()` retorna array vacío en caso de error (try-catch implementado en sesión 3.2).
    - La página siempre renderiza 8 slots usando `Array.from({ length: 8 })` y `teamSlots[i] || null`.
    - `TeamSlot` component maneja gracefully el caso `data === null` mostrando estado "Empty" con icono User.
  - **Build Status:** ✅ Lint pasó sin warnings ni errores. Build completado exitosamente en 1247.7ms con Turbopack. TypeScript compila sin errores. Ruta `/dashboard` genera correctamente con loading state.
- **2026-01-15:** Sesión 3.4: Polling para Team View Dashboard.
  - **Archivo creado:**
    - `components/team-view-auto-refresh.tsx`: Client Component que implementa auto-refresh cada 30 segundos usando `setInterval` y `router.refresh()`.
  - **Patrón de Polling Implementado:**
    - **Híbrido Server + Client:** Mantiene Server Component para data fetching (evita client-side waterfalls), pero usa Client Component para polling logic.
    - **router.refresh():** Método de Next.js que re-ejecuta el Server Component sin recargar la página completa. Esto permite mantener los beneficios de Server Components (no exponer DB queries al cliente) mientras se actualiza la data periódicamente.
    - **Interval de 30s:** Constante `POLL_INTERVAL = 30_000` ms configurable.
    - **Cleanup automático:** `useEffect` retorna función de cleanup que ejecuta `clearInterval()` al desmontar el componente, evitando memory leaks.
  - **Optimizaciones de Performance (React Best Practices):**
    - **Best Practice 5.5:** Lazy state initialization con `useState(() => new Date())` para evitar crear objeto Date en cada render.
    - **Best Practice 5.3:** Dependencies array mínimo en useEffect (solo `[router]`).
    - **Best Practice 4.2:** Alternativa a SWR - usa router.refresh() nativo de Next.js en vez de librería externa, reduciendo bundle size.
    - **Zero visual footprint:** Componente retorna `null`, es puramente side-effect (no afecta layout).
  - **Logging de Debug:**
    - Console.log condicional solo en `NODE_ENV === 'development'` con timestamp de último refresh.
    - Útil para verificar manualmente que el polling esté funcionando en dev tools.
  - **Integración en Dashboard:**
    - `app/(dashboard)/dashboard/page.tsx` actualizado para importar y renderizar `<TeamViewAutoRefresh />` como primer hijo.
    - Comentarios en código actualizados para documentar el patrón de auto-refresh.
  - **Verificación Manual Requerida:**
    - Para testear en Chrome: Ejecutar `npm run dev`, abrir `/dashboard`, verificar en console logs cada 30s.
    - Observar que las tareas in_progress se actualizan automáticamente si se modifican en otra pestaña o por otro usuario.
  - **Build Status:** ✅ Lint pasó sin errores. Build completado exitosamente en 1408.7ms con Turbopack. TypeScript compila sin errores. Componente client importado correctamente en Server Component.
- **2026-01-15:** Sesión 4.1: Tablero Kanban Base.
  - **Archivos creados:**
    - `app/actions/kanban.ts`: Server Action `getKanbanData()` que retorna tareas agrupadas por status (backlog, todo, in_progress, done).
    - `components/task-card.tsx`: Componente presentacional para renderizar una tarea individual con título, descripción, assignee y tiempo relativo.
    - `components/kanban-column.tsx`: Componente presentacional para renderizar una columna del Kanban con header, contador de tareas y lista de TaskCards.
  - **Archivos actualizados:**
    - `app/(dashboard)/dashboard/kanban/page.tsx`: Reemplazado placeholder con implementación real usando `getKanbanData()` y componentes `KanbanColumn`.
  - **Patrón de Data Fetching:**
    - Server Component en `page.tsx` ejecuta `await getKanbanData()` para fetch server-side (evita client-side waterfalls - Best Practice 1.1).
    - `getKanbanData()` usa LEFT JOIN para obtener assignee data en una sola query, luego paralleliza queries de creator data con Promise.all (Best Practice 1.4).
    - Tareas ordenadas por `updatedAt DESC` para mostrar las más recientes primero.
    - Retorna objeto `KanbanData` con arrays por status: `{ backlog: [], todo: [], in_progress: [], done: [] }`.
  - **Componentes implementados:**
    - **TaskCard:** Muestra título (máx 200 chars), descripción truncada con `line-clamp-2`, avatar del assignee (Next.js Image con width/height - Best Practice 2.1), y tiempo relativo con helper `getRelativeTime()` (Best Practice 7.8 - early returns).
    - **KanbanColumn:** Renderiza header con título y badge de contador con color dinámico por status (neutral/blue/amber/green), lista de TaskCards, y estado vacío con "No tasks" cuando no hay tareas.
  - **Optimizaciones de Performance:**
    - Next.js Image component para avatares (Best Practice 2.1).
    - Componentes puros presentacionales sin data fetching (minimiza serialización en RSC boundary - Best Practice 3.2).
    - Helper `getRelativeTime()` con early returns (Best Practice 7.8).
    - Helper `getColorClasses()` con switch statement para mapeo status → colores Tailwind.
  - **Responsive Grid:**
    - CSS classes: `grid-cols-1 md:grid-cols-2 xl:grid-cols-4` para layout 1xN (mobile), 2x2 (tablet), 1x4 (desktop).
    - Altura mínima de columna: `min-h-[600px]` para evitar colapso con pocas tareas.
    - Columnas con `overflow-y-auto` para scroll independiente cuando hay muchas tareas.
  - **Tipos Exportados:**
    - `KanbanTaskData`: Task con assignee y creator info completa.
    - `KanbanData`: Objeto con arrays de tasks por status.
  - **Manejo de Estados Vacíos:**
    - Cada columna muestra placeholder "No tasks" con border dashed cuando no hay tareas en ese status.
    - `getKanbanData()` retorna estructura vacía en caso de error (try-catch con console.error).
  - **Build Status:** ✅ Lint pasó sin warnings. Build completado exitosamente en 1403.8ms con Turbopack. TypeScript compila sin errores. Ruta `/dashboard/kanban` renderiza correctamente con 4 columnas.
- **2026-01-15:** Sesión 4.2: Integración de @dnd-kit para Drag and Drop.
  - **Dependencias instaladas:**
    - `@dnd-kit/core@6.3.1`: Core library para drag and drop context y hooks.
    - `@dnd-kit/sortable@10.0.0`: Componentes sortable para listas ordenables.
    - `@dnd-kit/utilities@3.2.2`: Utilities para transformaciones CSS y helpers.
  - **Archivos creados:**
    - `components/kanban-board.tsx`: Client Component wrapper que maneja la lógica de drag and drop con DndContext.
  - **Archivos actualizados:**
    - `components/task-card.tsx`: Convertido a Client Component con hook `useDraggable()`. Añadido prop `isDragging` para styling visual durante drag.
    - `components/kanban-column.tsx`: Convertido a Client Component con hook `useDroppable()`. Añadido prop `id` para identificación de drop zone. Feedback visual con border azul cuando `isOver`.
    - `app/(dashboard)/dashboard/kanban/page.tsx`: Actualizado para usar `<KanbanBoard />` wrapper en vez de renderizar columnas directamente.
  - **Arquitectura de DnD:**
    - **Patrón Híbrido Server + Client:** Page.tsx sigue siendo Server Component para data fetching (evita client-side waterfalls - Best Practice 1.1), pero delega lógica de drag and drop a Client Component.
    - **DndContext Provider:** Envuelve las 4 columnas del Kanban con sensors y collision detection configurados.
    - **Sensors:** Usa `PointerSensor` con `activationConstraint: { distance: 5 }` para prevenir drags accidentales en clicks normales.
    - **Collision Detection:** Usa `closestCorners` algorithm de @dnd-kit para determinar drop target más cercano.
  - **Flujo de Drag and Drop:**
    1. **onDragStart:** Encuentra la task siendo arrastrada y la guarda en state (`activeTask`) para mostrar en DragOverlay.
    2. **onDragEnd:** Identifica columna de destino (`over.id`), verifica si status cambió, y ejecuta `updateTaskStatus()` server action si es necesario.
    3. **DragOverlay:** Muestra clon de la task con rotación y opacidad durante el drag para mejor UX.
  - **Server Action Integration:**
    - Usa `updateTaskStatus()` existente (implementado en Task 2.3) para actualizar status de task en DB.
    - La Server Action maneja la transacción atómica y la lógica de "Single In-Progress Task".
    - `revalidatePath()` en la Server Action actualiza automáticamente el UI después del drop (sin necesidad de refetch manual).
  - **Optimizaciones de Performance (React Best Practices):**
    - **Best Practice 5.5:** Lazy state initialization con `useState<KanbanTaskData | null>(null)` (no crea objeto en cada render).
    - **Best Practice 2.1:** Mantiene uso de Next.js Image component en TaskCard.
    - **Best Practice 6.3:** Static JSX structure hoisted en componentes.
    - **Best Practice 1.1:** No crea client-side waterfalls - toda la data viene de Server Component initial fetch.
  - **Visual Feedback:**
    - TaskCard muestra `cursor-grab` en hover para indicar que es draggable.
    - KanbanColumn muestra border azul y background azul transparente cuando task está sobre ella (`isOver` state).
    - DragOverlay muestra clon de task con `rotate-3` y `opacity-80` durante drag.
  - **Edge Cases Manejados:**
    - Si task se dropea fuera de una droppable area (`!over`), no hace nada (vuelve a posición original).
    - Si task se dropea en la misma columna donde estaba (`task.status === newStatus`), no hace update innecesario.
    - Error logging en consola si `updateTaskStatus()` falla (TODO en código: mostrar toast en Task 4.3).
  - **Build Status:** ✅ Lint pasó sin errores. Build completado exitosamente en 1284.5ms con Turbopack. TypeScript compila sin errores. 9/9 unit tests pasaron. Drag and drop funcional implementado (E2E testing pendiente en Task 5.4).
- **2026-01-15:** Sesión 4.3: Optimistic UI para Kanban.
  - **Dependencia instalada:**
    - `sonner@1.x`: Librería de toast notifications con soporte dark mode y animaciones suaves.
  - **Archivos actualizados:**
    - `components/kanban-board.tsx`: Implementada lógica de Optimistic UI con state management local.
    - `app/layout.tsx`: Agregado `<Toaster />` component de sonner con posición bottom-right y richColors.
  - **Patrón de Optimistic UI:**
    - **Local State:** Añadido `useState<KanbanData>(initialData)` para mantener copia local de las tareas organizadas por columnas.
    - **Immediate Update:** En `handleDragEnd()`, actualiza el state local ANTES de ejecutar la Server Action, moviendo la task de la columna vieja a la nueva instantáneamente.
    - **Revert on Error:** Si `updateTaskStatus()` falla, revierte el cambio moviendo la task de vuelta a su columna original y muestra toast de error.
    - **Success Feedback:** Muestra toast de éxito cuando el server action completa correctamente.
  - **Implementación Técnica:**
    - Función `handleDragStart()` actualizada para buscar task en `kanbanData` (state local) en vez de `initialData`.
    - Función `handleDragEnd()` reescrita con 3 fases:
      1. **Optimistic Update:** `setKanbanData()` con lógica de remove + add inmediatamente.
      2. **Server Action:** `await updateTaskStatus()` persiste el cambio en DB.
      3. **Revert or Confirm:** Si falla, ejecuta `setKanbanData()` reverso y muestra `toast.error()`. Si tiene éxito, muestra `toast.success()`.
    - Todas las columnas renderizadas con `kanbanData` en vez de `initialData` para reflejar cambios optimistas.
  - **Toast Notifications:**
    - `toast.error()`: Usado para "Task not found", fallos de server action, y otros errores.
    - `toast.success()`: Usado para "Task moved successfully" cuando server action completa.
    - Toaster configurado con `richColors` para colores semánticos automáticos (verde para success, rojo para error).
    - Posición `bottom-right` para no obstruir contenido principal del Kanban.
  - **Optimizaciones de Performance (React Best Practices):**
    - **Best Practice 4.3:** Implementa Optimistic UI para feedback instantáneo, eliminando delay perceptible entre drag-drop y actualización visual.
    - **Best Practice 5.5:** Lazy state initialization con `useState<KanbanData>(initialData)`.
    - **Best Practice 5.1:** State read diferido - solo accede a `kanbanData` cuando se necesita (en handleDragStart, handleDragEnd, render).
    - **Best Practice 2.1:** Mantiene Next.js Image optimization en TaskCard.
  - **Edge Cases Manejados:**
    - Si task no se encuentra durante drag, muestra toast.error y sale early.
    - Si task se dropea en misma columna, no ejecuta update (early return).
    - Si server action falla, state local se revierte exactamente a estado anterior (no se pierde data).
    - Revalidación automática por server action actualiza `initialData` en siguiente render server-side (mantiene sincronización).
  - **UX Improvements:**
    - **Zero Delay:** Task se mueve visualmente al instante al hacer drop (antes había ~200-500ms delay visible).
    - **Error Recovery:** Si falla, task vuelve automáticamente a su posición original con mensaje explicativo.
    - **Success Feedback:** Confirmación visual explícita de que el cambio se persistió correctamente.
    - **No Blocking:** El usuario puede seguir interactuando con el Kanban mientras la server action se ejecuta en background.
  - **Testing Manual:**
    - ✅ Lint pasó sin errores.
    - ✅ Build completado exitosamente en 1492.2ms con Turbopack.
    - ⚠️ Manual testing requerido: Abrir `/dashboard/kanban`, hacer drag de una task a otra columna, verificar que se mueva instantáneamente y que aparezca toast de success.
    - ⚠️ Error testing requerido: Simular fallo de network/DB para verificar que revert funciona correctamente (pendiente para Task 5.4 E2E tests).
  - **Build Status:** ✅ Lint pasó sin errores. Build completado exitosamente en 1492.2ms con Turbopack. TypeScript compila sin errores. 9/9 unit tests pasaron. Optimistic UI implementado - manual testing pendiente en navegador.
- **2026-01-15:** Sesión 5.1: Panel de Activity Feed.
  - **Archivos creados:**
    - `app/actions/activity.ts`: Server Action `getActivityFeed()` que retorna los últimos 20 eventos de activity con info de usuario y tarea.
    - `components/activity-item.tsx`: Componente presentacional para renderizar un evento individual con icon, mensaje formateado, avatar del usuario y timestamp relativo.
    - `app/(dashboard)/dashboard/activity/loading.tsx`: Loading skeleton para la página de activity con 10 items placeholder.
  - **Archivos actualizados:**
    - `app/(dashboard)/dashboard/activity/page.tsx`: Convertido a async Server Component que fetch data con `getActivityFeed()` y renderiza lista de `ActivityItem` components o empty state.
  - **Patrón de Data Fetching:**
    - Server Component en `page.tsx` ejecuta `await getActivityFeed()` server-side (Best Practice 1.1 - evita client-side waterfalls).
    - `getActivityFeed()` usa LEFT JOIN para obtener user y task data en una sola query (Best Practice 1.4 - paralelización).
    - Query optimizada: ordenada por `activity.createdAt DESC` con `LIMIT 20`, usando índice existente `activity_created_at_idx`.
  - **Componentes implementados:**
    - **ActivityItem:** Muestra icon dinámico por action type (CheckCircle2, ArrowRightCircle, UserPlus, Edit3, Trash2), avatar del usuario, mensaje formateado con detalles del cambio (usando metadata JSONB), y timestamp relativo con helper `getRelativeTime()` (Best Practice 7.8 - early returns).
    - **getActivityMessage():** Helper function que formatea mensajes human-readable basados en action type y metadata. Incluye manejo especial para cada tipo de evento: created, status_changed, assigned, updated, deleted.
    - **formatStatus():** Helper function que convierte status enums ('in_progress') a strings legibles ('In Progress').
  - **Optimizaciones de Performance (React Best Practices):**
    - **Best Practice 1.1:** Server Component fetch (sin client-side waterfalls).
    - **Best Practice 1.4:** LEFT JOIN para paralelizar queries de user y task en una sola query.
    - **Best Practice 2.1:** Next.js Image component para avatares de usuarios.
    - **Best Practice 3.2:** Componente puro presentacional (minimiza serialización en RSC boundary).
    - **Best Practice 7.8:** Early returns en helpers (`getActionIcon()`, `getActivityMessage()`, `getRelativeTime()`, `formatStatus()`).
  - **Tipos Exportados:**
    - `ActivityData`: Activity event con user completo (id, name, email, imageUrl) y task opcional (id, title). Metadata tipado como `Record<string, unknown> | null` para flexibilidad.
  - **Manejo de Estados:**
    - Loading skeleton con 10 items que replica estructura de `ActivityItem`.
    - Empty state con icon de Activity y mensaje "No activity yet" cuando no hay eventos.
    - Error handling con try-catch en `getActivityFeed()` que retorna array vacío y logea error en consola.
  - **Formato de Mensajes:**
    - **created:** "created task \"{title}\""
    - **status_changed:** "moved \"{title}\" from {oldStatus} to {newStatus}"
    - **assigned:** "assigned \"{title}\" to someone"
    - **updated:** "updated title/description of \"{title}\""
    - **deleted:** "deleted task \"{title}\""
    - Incluye fallbacks para casos donde metadata no está completa o task fue eliminado.
  - **Testing Manual:**
    - ⚠️ Manual testing requiere configurar Clerk credentials reales y DATABASE_URL en `.env.local` (actualmente usa placeholders).
    - ⚠️ Para testear funcionalidad completa: crear tareas, cambiar status, actualizar metadata, eliminar tareas, y verificar que aparezcan en `/dashboard/activity` con mensajes formateados correctamente.
    - ⚠️ Verificar que loading skeleton aparece durante fetch inicial.
    - ⚠️ Verificar que empty state aparece cuando no hay activity events.
  - **Build Status:** ✅ Lint pasó sin warnings. Build completado exitosamente en 1276.7ms con Turbopack. TypeScript compila sin errores. 9/9 unit tests pasaron. Ruta `/dashboard/activity` generada correctamente en production build.
- **2026-01-15:** Sesión 5.2: Logging de Actividad (Verification).
  - **Status:** ✅ Task 5.2 ya estaba completada en sesiones previas (2.2, 2.3, 2.5).
  - **Verificación realizada:**
    - Revisión de `app/actions/tasks.ts`: Los 4 server actions (createTask, updateTaskStatus, deleteTask, updateTaskMetadata) tienen logging de actividad implementado correctamente.
    - Revisión de `db/schema.ts`: Tabla `activity` definida con campos correctos (id, taskId, userId, action, metadata, createdAt).
    - Revisión de `db/migrations/0001_brave_moonstone.sql`: Migración correcta con enum `activity_action`, foreign keys CASCADE, e índices optimizados.
    - Revisión de `app/actions/__tests__/tasks.test.ts`: Test suite incluye test específico para verificar activity logging en `updateTaskStatus`.
  - **Patrones de Activity Logging confirmados:**
    - **createTask:** Logs action `'created'` con metadata `{ title, assigneeId }`.
    - **updateTaskStatus:** Logs action `'status_changed'` con metadata `{ oldStatus, newStatus, taskTitle }` dentro de transacción atómica.
    - **deleteTask:** Logs action `'deleted'` con metadata `{ title, status, assigneeId }` ANTES del DELETE para preservar referencia.
    - **updateTaskMetadata:** Logs action `'updated'` con metadata `{ oldTitle, newTitle, oldDescription, newDescription, fieldsUpdated }`.
  - **Cobertura de Actions:**
    - ✅ Todos los server actions de Fase 2 insertan registro en tabla `activity`.
    - ✅ Todas las transacciones atómicas incluyen activity logging como parte del transaction block.
    - ✅ Activity feed (Task 5.1) consume correctamente los datos de la tabla `activity`.
  - **Build Status:** ✅ Lint pasó sin errores. Build completado exitosamente en 1429.5ms con Turbopack (Next.js 16.1.2). TypeScript compila sin errores. 9/9 unit tests pasaron. Task 5.2 verificada como completa.
- **2026-01-15:** Sesión 5.3: Error Boundaries y Toasts.
  - **Status:** ✅ Task completada con implementación de Error Boundaries en dos niveles.
  - **Sonner Toast Library:**
    - ✅ Ya instalado en sesión previa (4.3) como dependencia `sonner@2.0.7`.
    - ✅ `<Toaster />` component ya configurado en `app/layout.tsx` con posición `bottom-right` y `richColors` enabled.
    - ✅ `toast.error()` y `toast.success()` ya en uso en `components/kanban-board.tsx` para feedback de drag and drop operations.
  - **Archivos creados:**
    - `app/error.tsx`: Global Error Boundary que captura errores en toda la aplicación.
    - `app/(dashboard)/error.tsx`: Dashboard Error Boundary específico para errores dentro del route group del dashboard.
  - **Patrón de Error Boundaries:**
    - **Global Error Boundary (`app/error.tsx`):**
      - Renderiza pantalla completa con dark mode styling (neutral-950 bg).
      - Muestra icon de alerta (AlertCircle de lucide-react).
      - Mensaje user-friendly: "Something went wrong" sin exponer detalles técnicos.
      - Muestra error.message en bloque de código si está disponible.
      - Botones de acción: "Try again" (reset) y "Go home" (redirect a /).
      - Muestra error.digest (error ID de Next.js) para soporte técnico si está disponible.
      - `useEffect` con dependency [error] para logging en console.
    - **Dashboard Error Boundary (`app/(dashboard)/error.tsx`):**
      - Diseño más contextual que se integra con el estilo del dashboard.
      - Mensaje específico: "Failed to load dashboard" con explicación de posibles causas.
      - Error details en bloque expandido con formato mono.
      - Botones: "Try again" (reset con icon RefreshCw) y "Go to dashboard" (Link con icon Home).
      - Sección de "Need help?" con reference ID y mensaje de soporte.
      - Usa Next.js Link component para navegación sin full page reload (Best Practice).
  - **Optimizaciones de Performance (React Best Practices):**
    - **Best Practice 5.3:** Minimal useEffect dependencies (solo [error]).
    - **Best Practice 7.8:** Early returns implícitos en conditional rendering (error.message, error.digest).
    - **Best Practice 6.7:** Conditional rendering explícito para error details opcionales.
    - Client Components requeridos por Next.js para Error Boundaries (directiva 'use client' al inicio).
  - **UX Improvements:**
    - **Graceful Degradation:** Errores no crashean toda la app - se muestran en boundary más cercano.
    - **Clear Actions:** Usuarios tienen opciones claras para recovery (retry o volver a página segura).
    - **Dark Mode:** Error UI mantiene el estilo dark mode consistente con toda la aplicación.
    - **Error Context:** Dashboard error boundary provee contexto más específico que global error.
    - **Support Info:** Error digest permite al equipo de soporte debugging eficiente.
  - **Integration con Sonner:**
    - Error boundaries complementan toasts: Toasts para feedback en tiempo real de acciones (success/error de operaciones), Error boundaries para errores fatales que impiden renderizado.
    - Kanban drag and drop usa toasts para feedback inmediato (Task 4.3).
    - Server Actions pueden fallar sin crashear la UI (error boundary captura solo render errors).
  - **Testing Manual Requerido:**
    - ⚠️ Manual testing: Simular error en Server Component (throw new Error en page.tsx) para verificar que error boundary captura correctamente.
    - ⚠️ Verificar que "Try again" button ejecuta reset y re-intenta renderizado.
    - ⚠️ Verificar que "Go home" / "Go to dashboard" buttons navegan correctamente.
    - ⚠️ Verificar que error.message y error.digest se muestran cuando están disponibles.
    - ⚠️ Testear en Chrome DevTools con Network throttling para simular errores de fetch.
  - **Arquitectura de Error Handling:**
    - **Nivel 1 - Global (`app/error.tsx`):** Captura errores no manejados en toda la app (layout raíz, sign-in/sign-up, etc).
    - **Nivel 2 - Dashboard (`app/(dashboard)/error.tsx`):** Captura errores específicos del dashboard (data fetching, component rendering).
    - **Nivel 3 - Toasts (sonner):** Feedback de operaciones en tiempo real (server actions, mutations).
    - **Nivel 4 - Inline Error States:** Componentes individuales pueden manejar sus propios error states (ej: empty states en activity feed).
  - **Future Improvements (Out of Scope for MVP):**
    - Integración con servicio de error tracking (Sentry, LogRocket) en producción.
    - Error recovery strategies más sofisticadas (retry with exponential backoff).
    - Offline detection y manejo de errores de connectividad.
  - **Build Status:** ✅ Lint pasó sin warnings. Build completado exitosamente en 1372.9ms con Turbopack (Next.js 16.1.2). TypeScript compila sin errores. 9/9 unit tests pasaron. Task 5.3 completada e integrada correctamente.
